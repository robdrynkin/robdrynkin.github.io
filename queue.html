<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />
<title>Queue</title>
<meta name="authors" content="Ivan Rybin  Robert Drynkin" />
<meta name="date" content="July 30, 2021" />
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.min.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="queue">
<h1 class="title">Queue</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Authors:</th>
<td>Ivan Rybin
<br />Robert Drynkin</td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>July 30, 2021</td></tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<hr class="docutils" />
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Set Warnings</span> <span class="s2">&quot;-extraction-opaque-accessed,-extraction,-notation-overridden&quot;</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> ssreflect ssrfun ssrbool eqtype ssrnat seq. <span class="c">(* coq-mathcomp-ssreflect *)</span></span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> Equations <span class="kn">Require Import</span> Equations. <span class="c">(* coq-equations *)</span></span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> QuickChick <span class="kn">Require Import</span> QuickChick. <span class="c">(* coq-quickchick *)</span></span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Import</span> GenLow GenHigh. <span class="c">(* from QuickChick *)</span></span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> zify. <span class="c">(* coq-mathcomp-zify *)</span></span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> deriving <span class="kn">Require Import</span> deriving. <span class="c">(* coq-deriving *)</span></span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> mathcomp.ssreflect <span class="kn">Require Import</span> tuple.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight"><span class="c">(* From mathcomp Require Import ssreflect ssrfun ssrbool eqtype ssrnat. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> seq choice fintype.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kt">Set</span> Equations <span class="kn">Transparent</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Global Set</span> Bullet Behavior <span class="s2">&quot;None&quot;</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Set Implicit Arguments</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Unset Strict Implicit</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Unset Printing Implicit Defensive</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">Queue</span>.</span></span></span></pre><div class="section" id="queue-abstractions">
<h1>Queue abstractions</h1>
<p>IUnsafeQueue contains all necessary queue methods but doesn't give any guarantees about correctness.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Structure</span> <span class="nf">IUnsafeQueue</span> {<span class="nv">Q</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>} := MkUnsafeQueue {
    empty : <span class="kr">forall</span> {<span class="nv">A</span>}, Q A;
    isEmpty : <span class="kr">forall</span> {<span class="nv">A</span>}, Q A -&gt; bool;
    push : <span class="kr">forall</span> {<span class="nv">A</span>}, Q A -&gt; A -&gt; Q A;
    head : <span class="kr">forall</span> {<span class="nv">A</span>}, Q A -&gt; option A;
    tail : <span class="kr">forall</span> {<span class="nv">A</span>}, Q A -&gt; Q A;
}.</span></span></span></pre><p>We will use list queue as a specification for other queues</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">ListQueue</span> (<span class="nv">A</span> : <span class="kt">Type</span>) := seq A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">listQueueImpl</span>: @IUnsafeQueue ListQueue :=
{|
  empty := <span class="kr">fun</span> <span class="nv">A</span> =&gt; Nil A;
  isEmpty := <span class="kr">fun</span> <span class="nv">A</span> <span class="nv">q</span> =&gt; <span class="kr">match</span> q <span class="kr">with</span> | Nil _ =&gt; true | _ =&gt; false <span class="kr">end</span>;
  push := <span class="kr">fun</span> <span class="nv">A</span> <span class="nv">q</span> <span class="nv">v</span> =&gt; q ++ [:: v];
  head := <span class="kr">fun</span> <span class="nv">A</span> <span class="nv">q</span> =&gt; ohead q;
  tail := <span class="kr">fun</span> <span class="nv">A</span> <span class="nv">q</span> =&gt; <span class="kr">match</span> q <span class="kr">with</span> | Nil _ =&gt; Nil A | Cons _ x xs =&gt; xs <span class="kr">end</span>;
|}.</span></span></span></pre><p>A common representation for purely functional queues is as a pair of stacks f and r,
where f contains the front elements of the queue in the correct order and r contains
the rear elements of the queue in reverse order. For example, a queue containing the
integers 1..6 might be represented by the stacks f = [1, 2, 3] and r = [6, 5, 4].
This representation is described by the following datatype:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">TwoStackQueue</span> (<span class="nv">A</span> : <span class="kt">Type</span>) := MkQueue (f r : seq A).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Derive</span> (Arbitrary, <span class="kn">Show</span>) <span class="kr">for</span> TwoStackQueue.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">twoStackQueueUnsafeImpl</span>: @IUnsafeQueue TwoStackQueue :=
{|
  empty := <span class="kr">fun</span> <span class="nv">A</span> =&gt; MkQueue (Nil A) (Nil A);
  isEmpty := (<span class="kr">fun</span> <span class="nv">A</span> <span class="nv">q</span> =&gt; <span class="kr">match</span> q <span class="kr">with</span>
    | MkQueue (Nil _) (Nil _) =&gt; true
    | _ =&gt; false
    <span class="kr">end</span>);
  push := (<span class="kr">fun</span> <span class="nv">A</span> <span class="nv">q</span> <span class="nv">v</span> =&gt; <span class="kr">match</span> q <span class="kr">with</span>
    | MkQueue f r =&gt; MkQueue f (v :: r)
    <span class="kr">end</span>);
  head := (<span class="kr">fun</span> <span class="nv">A</span> <span class="nv">q</span> =&gt; <span class="kr">match</span> q <span class="kr">with</span>
    | MkQueue (Cons _ x _) _ =&gt; Some x
    | MkQueue (Nil _)      r =&gt; ohead (rev r)
    <span class="kr">end</span>);
  tail := (<span class="kr">fun</span> <span class="nv">A</span> <span class="nv">q</span> =&gt; <span class="kr">match</span> q <span class="kr">with</span>
    | MkQueue (Nil _) t =&gt; MkQueue (behead (rev t)) (Nil A)
    | MkQueue (Cons _ _ xs) r    =&gt; MkQueue xs r
    <span class="kr">end</span>);
|}.</span></span></span></pre><p>Safe queue holds unfase queue method, projection to the specification model and proofs of correctness.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Structure</span> <span class="nf">ISafeQueue</span> {<span class="nv">Q</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>} := MkSafeQueue {
    q :&gt; @IUnsafeQueue Q;

    ToModel : <span class="kr">forall</span> {<span class="nv">A</span>}, Q A -&gt; ListQueue A;

    CheckPush (A : <span class="kt">Type</span>) (x : A) (qq : Q A):
        ToModel (push q qq x) = (ToModel qq) ++ [:: x];

    CheckHead (A : <span class="kt">Type</span>) (x : A) (qq : Q A): 
        head q qq = head listQueueImpl (ToModel qq);
}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">TwoStackQueueToModel</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">q</span> : TwoStackQueue A) :=
  <span class="kr">match</span> q <span class="kr">with</span>
  | MkQueue f r =&gt; f ++ (rev r)
  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-v-chk0"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">TwoStackQueuePushOk</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : A) (<span class="nv">q</span> : TwoStackQueue A):
    TwoStackQueueToModel (push twoStackQueueUnsafeImpl q x) = (TwoStackQueueToModel q) ++ [:: x].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">TwoStackQueue A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">TwoStackQueueToModel
  (push twoStackQueueUnsafeImpl q x) =
TwoStackQueueToModel q ++ [:: x]</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-v-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">TwoStackQueue A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">TwoStackQueueToModel
  (push twoStackQueueUnsafeImpl q x) =
TwoStackQueueToModel q ++ [:: x]</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-v-chk2"><span class="highlight"><span class="nb">case</span>: q.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">f</span> <span class="nv">r</span> : seq A,
TwoStackQueueToModel
  (push twoStackQueueUnsafeImpl (MkQueue f r) x) =
TwoStackQueueToModel (MkQueue f r) ++ [:: x]</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-v-chk3"><span class="highlight"><span class="nb">move</span> =&gt; f r.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">TwoStackQueueToModel
  (push twoStackQueueUnsafeImpl (MkQueue f r) x) =
TwoStackQueueToModel (MkQueue f r) ++ [:: x]</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-v-chk4"><span class="highlight"><span class="nb">rewrite</span> /push //=.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f ++ rev (x :: r) = (f ++ rev r) ++ [:: x]</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-v-chk5"><span class="highlight"><span class="nb">rewrite</span> rev_cons.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f ++ rcons (rev r) x = (f ++ rev r) ++ [:: x]</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-v-chk6"><span class="highlight"><span class="nb">rewrite</span> -cats1 //=.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f ++ rev r ++ [:: x] = (f ++ rev r) ++ [:: x]</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-v-chk7"><span class="highlight"><span class="nb">rewrite</span> catA.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(f ++ rev r) ++ [:: x] = (f ++ rev r) ++ [:: x]</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">done</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-v-chk8"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">TwoStackQueueHeadOk</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : A) (<span class="nv">q</span> : TwoStackQueue A):
  head twoStackQueueUnsafeImpl q = head listQueueImpl (TwoStackQueueToModel q).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">TwoStackQueue A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">head twoStackQueueUnsafeImpl q =
head listQueueImpl (TwoStackQueueToModel q)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-v-chk9"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">TwoStackQueue A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">head twoStackQueueUnsafeImpl q =
head listQueueImpl (TwoStackQueueToModel q)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-v-chka"><span class="highlight"><span class="nb">case</span>: q.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">f</span> <span class="nv">r</span> : seq A,
head twoStackQueueUnsafeImpl (MkQueue f r) =
head listQueueImpl
  (TwoStackQueueToModel (MkQueue f r))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-v-chkb"><span class="highlight"><span class="nb">move</span> =&gt; f r.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">head twoStackQueueUnsafeImpl (MkQueue f r) =
head listQueueImpl
  (TwoStackQueueToModel (MkQueue f r))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-v-chkc"><span class="highlight"><span class="nb">rewrite</span> /push //=.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">match</span> f <span class="kr">with</span>
| [::] =&gt; ohead (rev r)
| x :: _ =&gt; Some x
<span class="kr">end</span> = ohead (f ++ rev r)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-v-chkd"><span class="highlight"><span class="nb">case</span>: f.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ohead (rev r) = ohead ([::] ++ rev r)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="queue-v-chke" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="queue-v-chke"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">l</span> : seq A),
Some a = ohead ((a :: l) ++ rev r)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-v-chkf"><span class="highlight"><span class="bp">done</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">l</span> : seq A),
Some a = ohead ((a :: l) ++ rev r)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-v-chk10"><span class="highlight"><span class="nb">move</span> =&gt; h t.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Some h = ohead ((h :: t) ++ rev r)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">by</span> <span class="nb">move</span> =&gt; //=.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">twoStackQueueImpl</span>: @ISafeQueue TwoStackQueue :=
{|
  q := twoStackQueueUnsafeImpl;
  ToModel := TwoStackQueueToModel;
  CheckPush := TwoStackQueuePushOk;
  CheckHead := TwoStackQueueHeadOk;
|}.</span></span></span></pre><p>Lets add ala go notations</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;&lt;e&gt;&quot;</span> := (empty twoStackQueueImpl) (<span class="kn">at level</span> <span class="mi">50</span>, <span class="kn">no associativity</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;q &lt;- x&quot;</span> := (push twoStackQueueImpl q x) (<span class="kn">at level</span> <span class="mi">50</span>, <span class="kn">no associativity</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;q -&gt;&quot;</span> := (tail twoStackQueueImpl q) (<span class="kn">at level</span> <span class="mi">50</span>, <span class="kn">no associativity</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;&lt;- q&quot;</span> := ((head twoStackQueueImpl q), (tail twoStackQueueImpl q)) (<span class="kn">at level</span> <span class="mi">50</span>, <span class="kn">no associativity</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-v-chk11"><span class="highlight"><span class="kn">Compute</span> &lt;e&gt; &lt;- <span class="mi">1</span> &lt;- <span class="mi">2</span> &lt;- <span class="mi">3</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= MkQueue [::] [:: <span class="mi">3</span>; <span class="mi">2</span>; <span class="mi">1</span>]
: TwoStackQueue nat</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-v-chk12"><span class="highlight"><span class="kn">Compute</span> (
    <span class="kr">let</span> <span class="nv">q</span> := &lt;e&gt; &lt;- <span class="mi">1</span> &lt;- <span class="mi">2</span> &lt;- <span class="mi">3</span> <span class="kr">in</span>
    &lt;- q
).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= (Some <span class="mi">1</span>, MkQueue [:: <span class="mi">2</span>; <span class="mi">3</span>] [::])
: option nat * TwoStackQueue nat</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-v-chk13"><span class="highlight"><span class="kn">Compute</span> (
    <span class="kr">let</span> <span class="nv">q0</span> := &lt;e&gt; &lt;- <span class="mi">1</span> &lt;- <span class="mi">2</span> &lt;- <span class="mi">3</span> <span class="kr">in</span>
    <span class="kr">let</span> (<span class="nv">a1</span>, q1) := &lt;- q0 <span class="kr">in</span>
    <span class="kr">let</span> (<span class="nv">a2</span>, q2) := &lt;- q1 <span class="kr">in</span>
    <span class="kr">let</span> (<span class="nv">a3</span>, q3) := &lt;- q2 <span class="kr">in</span>
    (a1, a2, a3, q3)
).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= (Some <span class="mi">1</span>, Some <span class="mi">2</span>, Some <span class="mi">3</span>, MkQueue [::] [::])
: option nat * option nat * option nat *
  TwoStackQueue nat</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">Queue</span>.</span></span></span></pre></div>
</div>
</div>
</div></body>
</html>
