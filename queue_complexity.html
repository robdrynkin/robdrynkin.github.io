<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />
<title>Queue complexity</title>
<meta name="authors" content="Ivan Rybin  Robert Drynkin" />
<meta name="date" content="July 30, 2021" />
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.min.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="queue-complexity">
<h1 class="title">Queue complexity</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Authors:</th>
<td>Ivan Rybin
<br />Robert Drynkin</td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>July 30, 2021</td></tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<hr class="docutils" />
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Set Warnings</span> <span class="s2">&quot;-extraction-opaque-accessed,-extraction,-notation-overridden&quot;</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> ssreflect ssrfun ssrbool eqtype ssrnat seq. <span class="c">(* coq-mathcomp-ssreflect *)</span></span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> Equations <span class="kn">Require Import</span> Equations. <span class="c">(* coq-equations *)</span></span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> QuickChick <span class="kn">Require Import</span> QuickChick. <span class="c">(* coq-quickchick *)</span></span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Import</span> GenLow GenHigh. <span class="c">(* from QuickChick *)</span></span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> zify. <span class="c">(* coq-mathcomp-zify *)</span></span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> deriving <span class="kn">Require Import</span> deriving. <span class="c">(* coq-deriving *)</span></span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> mathcomp.ssreflect <span class="kn">Require Import</span> tuple.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight"><span class="c">(* From mathcomp Require Import ssreflect ssrfun ssrbool eqtype ssrnat. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> seq choice fintype.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kt">Set</span> Equations <span class="kn">Transparent</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Global Set</span> Bullet Behavior <span class="s2">&quot;None&quot;</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Set Implicit Arguments</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Unset Strict Implicit</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Unset Printing Implicit Defensive</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">Monad</span>.</span></span></span></pre><p>something of type A can be computed in time O(n)</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">InTime</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">n</span> : nat) := box (a : A).</span></span></span></pre><p>private deconstrutor of our monad <code class="highlight coq"><span class="name">InTime</span></code>. Should not be used</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">unbox</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">n</span> : nat) (<span class="nv">boxed</span> : InTime A n) : A :=
  <span class="kr">match</span> boxed <span class="kr">with</span>
    | box _ a =&gt; a
  <span class="kr">end</span>.</span></span></span></pre><p>haskell like bind. Allows combining 2 monad computations</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">bind</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">n</span> <span class="nv">m</span> (<span class="nv">x</span> : InTime A n) (<span class="nv">f</span> : A -&gt; InTime B m) : InTime B (n + m) :=
  box (n + m) (unbox (f (unbox x))).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x &gt;&gt;= f&quot;</span> := (bind x f) (<span class="kn">at level</span> <span class="mi">1</span>, <span class="kn">no associativity</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;f =&lt;&lt; x&quot;</span> := (bind x f) (<span class="kn">at level</span> <span class="mi">1</span>, <span class="kn">no associativity</span>).</span></span></span></pre><p>haskell like fmap. Allows combining monad computation with pure one</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">fmap</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">n</span> (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : InTime A n) : InTime B n :=
  box n (f (unbox x)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;f &lt;$&gt; x&quot;</span> := (fmap f x) (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">no associativity</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x &lt;$$&gt; f&quot;</span> := (fmap f x) (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">no associativity</span>).</span></span></span></pre><p>TODO: n should be implicit argument</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">return_</span> <span class="nv">A</span> <span class="nv">n</span> <span class="nv">a</span>: InTime A n := box n a.</span></span></span></pre><p>if m = n and (x : InTime A m) then x is also (x : InTime A m)</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">bound_eq</span> <span class="nv">A</span> <span class="nv">m</span> <span class="nv">n</span> (<span class="nv">eq_mn</span> : m = n) (<span class="nv">x</span> : InTime A m) : InTime A n :=
  <span class="kr">let</span>: erefl <span class="kr">in</span> _ = n := eq_mn <span class="kr">return</span> InTime A n <span class="kr">in</span> x.</span></span></span></pre><p>if m + k = n and (x : InTime A m) then x can be bounded to upper time</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">bound_plus</span> <span class="nv">A</span> <span class="nv">m</span> <span class="nv">n</span> <span class="nv">k</span> (<span class="nv">eq_mkn</span> : m + k = n) (<span class="nv">x</span> : InTime A m) : InTime A n :=
  bound_eq eq_mkn (x &gt;&gt;= (return_ k)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-complexity-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-complexity-v-chk0"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">bound_leq_lem</span> <span class="nv">m</span> <span class="nv">n</span> : m &lt;= n -&gt; m + (n - m) = n.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m &lt;= n -&gt; m + (n - m) = n</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-complexity-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-complexity-v-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m &lt;= n -&gt; m + (n - m) = n</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">by</span> <span class="bp">lia</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>if m &lt;= n and (x : InTime A m) then x can time bound can be raised to n</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">bound_leq</span> <span class="nv">A</span> <span class="nv">m</span> <span class="nv">n</span> (<span class="nv">eq_mn</span> : m &lt;= n) (<span class="nv">x</span> : InTime A m) : InTime A n :=
  bound_plus (bound_leq_lem eq_mn) x.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">Monad</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">Queue</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Import</span> Monad.</span></span></span></pre><p>Queue Definition</p>
<p>Queue using 2 stacks</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">Queue</span> (<span class="nv">A</span> : <span class="kt">Type</span>) := MkQueue (f r : seq A).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Derive</span> (Arbitrary, <span class="kn">Show</span>) <span class="kr">for</span> Queue.</span></span><span class="alectryon-wsp"> </span></span></pre><p>Derive comes from QuickChick</p>
<p>field accessor</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">get_rev</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">q</span> : Queue A) :=
  <span class="kr">match</span> q <span class="kr">with</span>
  | MkQueue f r =&gt; r
  <span class="kr">end</span>.</span></span></span></pre><p>Monadic push for seq. Assume O(1)</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">monad_seq_push</span> <span class="nv">A</span> (<span class="nv">s</span> : seq A) (<span class="nv">x</span> : A) : InTime (seq A) <span class="mi">1</span> :=
  return_ <span class="mi">1</span> (x :: s).</span></span></span></pre><p>Monadic ohead for seq. Assume O(1)</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">monad_seq_ohead</span> <span class="nv">A</span> (<span class="nv">s</span> : seq A) : InTime (option A) <span class="mi">1</span> :=
  return_ <span class="mi">1</span> (ohead s).</span></span></span></pre><p>Monadic rev for seq. Assume O(size s)</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">monad_seq_rev</span> <span class="nv">A</span> (<span class="nv">s</span> : seq A) : InTime (seq A) (seq.size s) :=
  return_ (seq.size s) (rev s).</span></span></span></pre><p>Monadic match for seq. O(1)</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">monad_seq_match</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">n</span> (<span class="nv">s</span> : seq A)
           (<span class="nv">cons</span> : A -&gt; seq A -&gt; InTime B n)
           (<span class="nv">tail</span> : InTime B n)
  : InTime B (n + <span class="mi">1</span>) :=
  (return_ <span class="mi">1</span>) =&lt;&lt;
    <span class="kr">match</span> s <span class="kr">with</span>
    | (h :: t) =&gt; cons h t
    | [::] =&gt; tail
    <span class="kr">end</span>.</span></span></span></pre><p>Size of queue</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">size</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">q</span> : Queue A) : nat :=
  <span class="kr">match</span> q <span class="kr">with</span>
  | MkQueue f r =&gt; size f + size r
  <span class="kr">end</span>.</span></span></span></pre><p>Push in queue. O(1)</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">push</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">q</span> : Queue A) (<span class="nv">x</span> : A) : InTime (Queue A) <span class="mi">1</span> :=
  <span class="kr">match</span> q <span class="kr">with</span>
  | MkQueue f r =&gt; (MkQueue f) &lt;$&gt; (monad_seq_push r x)
  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-complexity-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-complexity-v-chk2"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">size_n</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">n</span> (<span class="nv">r</span> : seq A) :
  InTime B (seq.size r + n) -&gt; InTime B (@size A (MkQueue [::] r) + n).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">InTime B (seq.size r + n) -&gt;
InTime B (size (MkQueue [::] r) + n)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-complexity-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-complexity-v-chk3"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">InTime B (seq.size r + n) -&gt;
InTime B (size (MkQueue [::] r) + n)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">by</span> <span class="nb">rewrite</span> /size //=.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-complexity-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-complexity-v-chk4"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">size_n_add1_1</span> <span class="nv">A</span> <span class="nv">n</span> : InTime A (n + <span class="mi">1</span> + <span class="mi">1</span>) -&gt; InTime A n.+<span class="mi">2</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">InTime A (n + <span class="mi">1</span> + <span class="mi">1</span>) -&gt; InTime A n.+<span class="mi">2</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-complexity-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-complexity-v-chk5"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">InTime A (n + <span class="mi">1</span> + <span class="mi">1</span>) -&gt; InTime A n.+<span class="mi">2</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">by</span> <span class="nb">rewrite</span> !addn1.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span></span></pre><p>Head of queue. Completes in O(seq.size (get_rev q) + 1 + 1) = O((size q).+2)</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">head</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">q</span> : Queue A) :
  InTime (option A) ((seq.size (get_rev q)) + <span class="mi">1</span> + <span class="mi">1</span>) := 
  <span class="kr">match</span> q <span class="kr">with</span>
  | MkQueue f r =&gt;
    monad_seq_match f
                    (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">_</span> =&gt; return_ _ (Some x))
                    (bind (monad_seq_rev r) (@monad_seq_ohead A))
  <span class="kr">end</span>.</span></span></span></pre><p>Model with seq</p>
<p>Conversion from our queue to model</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">queue_to_model</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">q</span> : Queue A) :=
  <span class="kr">match</span> q <span class="kr">with</span>
  | MkQueue f r =&gt; f ++ (rev r)
  <span class="kr">end</span>.</span></span></span></pre><p>Push in model</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">model_push</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">s</span> : seq A) (<span class="nv">v</span> : A) : seq A := s ++ [:: v].</span></span></span></pre><p>Head of model queue</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">model_head</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">s</span> : seq A) : option A := ohead s.</span></span></span></pre><p>Queue Lemmas</p>
<p>Lemma that says that queue push is the same as our model</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-complexity-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-complexity-v-chk6"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">queue_push_ok</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">q</span> : Queue A) (<span class="nv">x</span> : A) :
  (@queue_to_model A) &lt;$&gt; (push q x) = return_ _ (model_push (queue_to_model q) x).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Queue A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(push q x) &lt;$$&gt; (queue_to_model (A:=A)) =
return_ <span class="mi">1</span> (model_push (queue_to_model q) x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-complexity-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-complexity-v-chk7"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Queue A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(push q x) &lt;$$&gt; (queue_to_model (A:=A)) =
return_ <span class="mi">1</span> (model_push (queue_to_model q) x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-complexity-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-complexity-v-chk8"><span class="highlight"><span class="nb">case</span>: q =&gt; f r.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(push (MkQueue f r) x) &lt;$$&gt; (queue_to_model (A:=A)) =
return_ <span class="mi">1</span>
  (model_push (queue_to_model (MkQueue f r)) x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-complexity-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-complexity-v-chk9"><span class="highlight"><span class="nb">rewrite</span> /push /monad_seq_push /return_ /fmap /model_push //=.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">box <span class="mi">1</span> (f ++ rev (x :: r)) =
box <span class="mi">1</span> ((f ++ rev r) ++ [:: x])</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">by</span> <span class="nb">rewrite</span> cats1 rcons_cat rev_cons.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>Lemma that says that queue head is the same as our model</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-complexity-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-complexity-v-chka"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">queue_head_ok</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">q</span> : Queue A) (<span class="nv">x</span> : A) :
  head q = return_ _ (model_head (queue_to_model q)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Queue A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">head q =
return_ (seq.size (get_rev q) + <span class="mi">1</span> + <span class="mi">1</span>)
  (model_head (queue_to_model q))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-complexity-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-complexity-v-chkb"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Queue A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">head q =
return_ (seq.size (get_rev q) + <span class="mi">1</span> + <span class="mi">1</span>)
  (model_head (queue_to_model q))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-complexity-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-complexity-v-chkc"><span class="highlight"><span class="nb">case</span>: q =&gt; f r.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">head (MkQueue f r) =
return_ (seq.size (get_rev (MkQueue f r)) + <span class="mi">1</span> + <span class="mi">1</span>)
  (model_head (queue_to_model (MkQueue f r)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="queue-complexity-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="queue-complexity-v-chkd"><span class="highlight"><span class="nb">rewrite</span> /head /bind /size /return_ /unbox /model_head /monad_seq_ohead //=.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">monad_seq_match f
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="kr">fun</span>=&gt; box (seq.size r + <span class="mi">1</span>) (Some x))
  (box (seq.size r + <span class="mi">1</span>) (ohead (rev r))) =
box (seq.size r + <span class="mi">1</span> + <span class="mi">1</span>) (ohead (f ++ rev r))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">by</span> <span class="nb">case</span>: f =&gt; //=.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre></div>
</div>
</div></body>
</html>
